# Принцип разделения интерфейсов (ISP) [draft]

Оригинальный текст из книги Робертом Мартина [Agile Principles, Patterns, and Practices](https://www.amazon.com/Agile-Principles-Patterns-Practices-C/dp/0131857258).

Этот принцип относится к недостаткам "жирных" интерфейсов. Говорят, что класс имеет «жирный» интерфейс, если функции этого интерфейса недостаточно сцепленные. Иными словами, интерфейс класса можно разбить на группы методов. Каждая группа предназначена для обслуживания разнотипных клиентов. Одним клиентам нужна одна группа методов, другим – другая.

---
**Принцип разделения интерфейсов (Interface Segregation Principle - ISP)**

*Клиенты не должны вынужденно зависеть от методов, которыми не пользуются.*

--

Принцип ISP допускает, что могут существовать объекты, нуждающиеся в несцепленных интерфейсах, однако предполагает, что клиентам необязательно знать, что это единый класс. Клиенты должны лишь знать об абстрактных интерфейсах, обладающих свойством сцепленности.

## Пример DIP

Рассмотрим охранную систему, в которой объекты ```Door``` (Дверь) можно запирать и отпирать, а также узнавать, открыта дверь или закрыта. Тип ```Door``` закодирован в виде интерфейса, чтобы клиенты могли использовать объекты, согласованные с интерфейсом двери, не зная о деталях конкретной реализации.

```java
public interface Door {
    void lock();
    
    void unlock();
    
    boolean isOpen();
}
```

Теперь предположим, что одна такая реализация, ```TimedDoor```, должна подавать звуковой сигнал, если дверь остается открытой слишком долго. Для этого ```TimedDoor``` взаимодействует с объектом ```Timer```.

```java
public class Timer {

public void register(int timeout, TimerClient client) {
    /* ... */
}

public interface TimerClient {
    
    void timeOut();
    
}
```

Если объект желает получать уведомление об истечении тайм-аута, он вызывает метод ```register``` объекта ```Timer```. Этому методу в качестве аргументов передаются величина тайм-аута и ссылка на объект ```TimerClient```, метод ```timeOut``` которого нужно вызвать, когда тайм-аут истечет.

"Жирные" классы приводят к неочевидным и вредным связям между их клиентами. Если одному клиенту требуется изменить жирный класс, то оказываются затронуты и все остальные классы. Поэтому клиенты должны зависеть только от методов, которые вызывают. Этого можно достичь путем разбиения интерфейса жирного класса на несколько интерфейсов, специально предназначенных для клиентов. В каждом таком интерфейсе объявляются только методы, которые вызывает конкретный клиент или группа клиентов. Затем жирный класс может унаследовать всем специальным для клиентов интерфейсам и реализовать их. Это разрывает зависимость клиента от методов, к которым он не обращается, и делает клиентов независимыми друг от друга.

Адаптировал: [Кротов Артём](https://fb.com/artem.v.krotov).

Остались вопросы? Задавай в [нашем чате](https://t.me/technicalexcellenceru).
