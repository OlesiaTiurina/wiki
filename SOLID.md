# SOLID - принципы [draft]

**SOLID** — мнемонический акроним, введённый Майклом Физерсом для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали 5 основных принципов объектно-ориентированного программирования и проектирования.

**Основные принципы**:

| __Инициалы__ | __Название__                                                                                               |
|--------------|------------------------------------------------------------------------------------------------------------|
| **S**RP      | [Принцип единственной ответственности (Single Responsibility Principle)](SingleResponsibilityPrinciple.md) |
| **O**CP      | [Принцип открытости/закрытости (Open–closed principle)](OpenClosedprinciple.md)                            |
| **L**SP      | [Принцип подстановки Барбары Лисков (Liskov substitution principle)](LiskovSubstitutionPrinciple.md)       |
| **I**SP      | [Принцип разделения интерфейсов (Interface segregation principle)](InterfaceSegregationPrinciple.md)       |
| **D**IP      | [Принцип инверсии зависимостей (Dependency inversion principle)](DependencyInversionPrinciple.md)          |

**Другие принципы**:

| __Инициалы__ | __Название__                                                                                                                                                   |
|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| REP          | [Принцип эквивалентности повторного использования и выпуска (Reuse/Release Equivalence Principle)](#принцип-эквивалентности-повторного-использования-и-выпуска)|
| CRP          | [Принцип совместного повторного использования (Common Reuse Principle)](#принцип-совместного-повторного-использования)                                         |
| CCP          | [Принцип общей закрытости (Common Closure Principle)](#принцип-общей-закрытости)                                                                               |
| ADP          | [Принцип ацикличности зависимостей (Acyclic Dependencies Principle)](#принцип-ацикличности-зависимостей)                                                       |
| SDP          | [Принцип устойчивых зависимостей (Stable-Dependencies Principle)](#принцип-устойчивых-зависимостей)                                                            |
| SAP          | [Принцип устойчивых абстракций (Stable-Abstractions Principle)](#принцип-устойчивых-абстракций)                                                                |


## Принцип эквивалентности повторного использования и выпуска

---
**Принцип эквивалентности повторного использования и выпуска (Reuse/Release Equivalence Principle – REP)**

Единица повторного использования равна единице выпуска.

---

Чего вы ожидаете от автора библиотеки классов, которую планируете повторно использовать? Разумеется, хотелось бы иметь хорошую документацию, работающий код, четко специфицированные интерфейсы и т. д. Но это еще не все.

Во-первых, чтобы повторное использование написанного этим автором кода вообще имело смысл, вы хотите иметь гарантию, что автор будет поддерживать свое детище. Ведь если поддерживать код предстоит вам, то придется потратить на его изучение массу времени, а тогда уж лучше спроектировать компонент поменьше, зато под свои конкретные нужды.

Во-вторых, вы хотите, чтобы автор извещал вас обо всех планируемых изменениях в интерфейсе и функциональности кода. Но одного извещения недостаточно. Нужно еще, чтобы автор обеспечил возможность отказаться от использования новых версий. А то, не дай бог, он выпустит новую версию как раз тогда, когда у вас трещит по швам график, или внесет изменения, несовместимые с вашей системой.

Но если вы решите отказаться от новой версии, то автор должен гарантировать поддержку старой версии в течение какого-то периода времени. Может быть, всего три месяца, может быть, год – это вопрос обсуждаемый. Но автор не может просто порвать с вами, отказав во всякой поддержке. Если автор не соглашается поддерживать старые версии, то вы всерьез задумайтесь, стоит ли использовать такой код и целиком зависеть от капризов автора.

Этот вопрос в основном политический. Он касается организационных аспектов процесса поддержки, призванного защитить интересы людей, собирающихся использовать сторонний код. Но политические и организационные вопросы оказывают глубокое влияние на способ пакетирования ПО. Для того чтобы дать гарантии, в которых нуждаются пользователи, автор организует свою программу в виде набора повторно используемых компонентов и присваивает им номера выпуска.

Таким образом, принцип REP гласит, что единица повторного использования, компонент, не может быть меньше единицы выпуска. Все, что предназначено для повторного использования, должно управляться какой-то системой учета выпусков. Не может быть так, чтобы разработчик просто написал какой-то класс и объявил его повторно используемым. О возможности повторного использования можно говорить только тогда, когда внедрена некая система учета выпусков и обеспечены гарантии извещения, надежности и поддержки, в которых так нуждаются потенциальные пользователи.

Принцип REP дает первую подсказку, как разбить дизайн на компоненты. Раз в основе повторного использования должны лежать компоненты, значит, повторно используемые компоненты должны состоять из повторно используемых классов. Поэтому по крайней мере некоторые компоненты должны содержать повторно используемые наборы классов. Тот факт, что разбиение программы определяется политическими факторами, поначалу выглядит настораживающим, но ведь ПО – не математически безупречная сущность, которую можно структурировать, руководствуясь исключительно математически строгими правилами. ПО – продукт деятельности человека, призванный служить человеческим нуждам. ПО создается людьми и для людей. И если мы собираемся его повторно использовать, то и разбивать на компоненты должны так, чтобы людям было удобно.

И какие из этого можно сделать выводы касательно внутренней структуры компонента? Рассматривать его состав следует с точки зрения потенциальных пользователей. Если компонент содержит ПО, которое допускает повторное использование, то в нем не должно быть частей, спроектированных без учета повторного использования. *Либо все классы, включенные в компонент, можно использовать повторно, либо ни один*.

Далее, сам факт повторного использования не является единственным критерием; следует еще принимать во внимание, кто будет использовать компонент. Конечно, библиотеку контейнерных классов можно использовать повторно. Как и каркас для построения финансового ПО. Но вряд ли стоит делать их частями одного и того же компонента, потому что далеко не все заинтересованные в библиотеке контейнерных классов нуждаются в финансовом каркасе. Таким образом, желательно, чтобы все классы в компоненте были ориентированы на одну и ту же аудиторию.

Плохо если потенциальные пользователи обнаружат в компоненте как необходимые, так и совершенно бесполезные для них классы.


## Принцип совместного повторного использования

---
**Принцип совместного повторного использования (Common Reuse Principle – CRP)**

Все классы внутри компонента используются совместно. Если вы можете повторно использовать один класс, то можете использовать и все остальные.

---

Этот принцип помогает решить, какие классы включать в компонент. CRP гласит, что классы, которые, скорее всего, будут использоваться совместно, принадлежат одному компоненту.

Классы редко используются изолированно. Обычно повторно используемые классы кооперируются с другими классами, являющимися частями одной и той же абстракции. CRP утверждает, что такие классы должны входить в один компонент. Естественно ожидать, что между классами в этом компоненте будет много взаимных зависимостей. Простой пример – класс контейнера и сопутствующие ему итераторы. Эти классы используются совместно, потому что они тесно связаны. И, значит, должны принадлежать одному компоненту.

Но CRP говорит не только о том, какие классы помещать в один компонент, а также о том, какие не помещать туда. Если один компонент пользуется другим, то между ними образуется зависимость. Может случиться так, что первому компоненту нужен всего один класс из второго. Но от этого зависимость отнюдь не становится слабее. Первый компонент все равно зависит от второго. При каждом новом выпуске второго компонента придется заново проверять и выпускать первый. И это справедливо даже в том случае, когда причиной нового выпуска используемого компонента является изменение в классе, который использующему компоненту не интересен.

Очень часто компоненты оформляются в виде DLL-библиотек. Если используемый компонент выпущен в виде DLL, то использующий его код зависит от этой DLL в целом. Любая модификация данной DLL, даже если речь идет об изменении класса, который никак не касается использующей программы, обязательно приводит к выпуску новой версии DLL. Новую DLL необходимо повторно развертывать и заново тестировать все использующие ее программы.

Поэтому если уж мой код зависит от некоторого компонента, то я хотел бы, чтобы он зависел от всех классов в этом компоненте. Иными словами, я хочу, чтобы классы, включенные в компонент, были неразделимы, чтобы не получилось так, что клиент зависит от одних и не зависит от других классов. Иначе мне придется заниматься повторным развертыванием и проверкой чаще, чем необходимо, тратя на это несоразмерно много времени.

Итак, принцип CRP даже больше говорит о том, какие классы не следует включать в один компонент, чем о том, какие следует. Смысл CRP в том, что классы, не являющиеся тесно связанными, не должны находиться в одном компоненте.

## Принцип общей закрытости

---
**Принцип общей закрытости (Common Closure Principle – CCP)**

Все классы внутри компонента должны быть закрыты относительно изменений одного и того же вида. Изменение, затрагивающее компонент, должно затрагивать все классы в этом компоненте и только в нем.

---

Это не что иное, как принцип единственной обязанности (SRP) в применении к компонентам. SRP говорит, что у класса не должно быть более одной причины для изменения, а CCP – что то же самое справедливо и для компонента.

В большинстве приложений пригодность для сопровождения важнее повторного использования. Если код приложения приходится изменять, то хотелось бы, чтобы все изменения были локализованы в одном компоненте, а не разбросаны по многим, поскольку это позволит ограничиться повторным развертыванием только одного изменившегося компонента. Другие компоненты, не зависящие от изменившегося, не нужно ни развертывать, ни заново проверять.

Принцип CCP рекомендует собирать в одном месте классы, которые могут изменяться по одним и тем же причинам. Если два класса настолько тесно связаны, физически или концептуально, что всегда изменяются вместе, то их естественно поместить в один компонент. Это уменьшит трудозатраты на повторный выпуск, проверку и распространение ПО.

Этот принцип неотъемлем от принципа открытости/закрытости (OCP). Ибо именно о «закрытости» в смысле OCP и идет речь в CCP. OCP гласит, что классы должны быть закрыты для модификации, но открыты для расширения. Но, как мы узнали, достичь стопроцентной закрытости невозможно. Закрытость должна быть стратегической целью. Мы проектируем систему так, чтобы она была закрыта относительно типичных изменений, с которыми нам приходилось ранее сталкиваться.

CCP развивает эту идею, рекомендуя включать классы, открытые для изменений одного и того же вида, в один компонент. Тогда в случае появления новых требований возрастают шансы на то, что удастся ограничиться изменением минимального числа компонентов.

## Принцип ацикличности зависимостей

---
**Принцип ацикличности зависимостей (Acyclic Dependencies Principle – ADP)**

В графе зависимостей между компонентами не должно быть циклов.

---

//TBD

## Принцип устойчивых зависимостей

---
**Принцип устойчивых зависимостей (Stable-Dependencies Principle – SDP)**

Зависимости должны быть направлены в сторону устойчивости.

---

//TBD

## Принцип устойчивых абстракций

---
**Принцип устойчивых абстракций (Stable-Abstractions Principle – SAP)**

Компонент должен быть столь же абстрактным, сколь и устойчивым.

---

//TBD


Остались вопросы? Задавай в [нашем чате](https://t.me/technicalexcellenceru).
