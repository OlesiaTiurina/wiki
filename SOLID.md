# SOLID - принципы

**SOLID** — мнемонический акроним, введённый Майклом Физерсом для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали 5 основных принципов объектно-ориентированного программирования и проектирования.

**Основные принципы**:

| __Инициалы__ | __Название__                                                                                                       |
|--------------|--------------------------------------------------------------------------------------------------------------------|
| **S**RP      | [Принцип единственной ответственности (Single Responsibility Principle)](#принцип-единственной-ответственности)    |
| **O**CP      | [Принцип открытости/закрытости (Open–closed principle)](#принцип-открытостизакрытости)                             |
| **L**SP      | [Принцип подстановки Барбары Лисков (Liskov substitution principle)](#принцип-подстановки-барбары-лисков)          |
| **I**SP      | [Принцип разделения интерфейсов (Interface segregation principle)](#принцип-разделения-интерфейсов)                |
| **D**IP      | [Принцип инверсии зависимостей (Dependency inversion principle)](#принцип-инверсии-зависимостей)                   |

**Другие принципы**:

| __Инициалы__ | __Название__                                                                                                                                                   |
|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| REP          | [Принцип эквивалентности повторного использования и выпуска (Reuse/Release Equivalence Principle)](#принцип-эквивалентности-повторного-использования-и-выпуска)|
| CRP          | [Принцип совместного повторного использования (Common Reuse Principle)](#принцип-совместного-повторного-использования)                                         |
| CCP          | [Принцип общей закрытости (Common Closure Principle)](#принцип-общей-закрытости)                                                                               |
| ADP          | [Принцип ацикличности зависимостей (Acyclic Dependencies Principle)](#принцип-ацикличности-зависимостей)                                                       |
| SDP          | [Принцип устойчивых зависимостей (Stable-Dependencies Principle)](#принцип-устойчивых-зависимостей)                                                            |
| SAP          | [Принцип устойчивых абстракций (Stable-Abstractions Principle)](#принцип-устойчивых-абстракций)                                                                |

## Принцип единственной ответственности

Этот принцип впервые был описан в работах [Тома ДеМарко](https://www.amazon.com/Structured-Analysis-System-Specification-DeMarco/dp/0138543801) и [Мейлира Пейдж-Джонса](https://www.amazon.com/Practical-Guide-Structured-Systems-Design/dp/0136907695/). Они назвали его *сцепленностью* (cohesion), определив ее как функциональную связанность элементов модуля. Далее мы будем понимать под сцепленностью силы, заставляющие модуль или класс изменяться.

---
**Принцип единственной ответственности (Single-Responsibility Principle – SRP)**

У класса должна быть только одна причина для изменения.

---

Почему так важно было разделять разные обязанности между разным классами? Потому, что каждая обязанность – это ось изменения. Любое изменение требований проявляется в изменении распределения обязанностей между классами. Если класс берет на себя несколько обязанностей, то у него появляется несколько причин для изменения.

Если класс отвечает за несколько действий, то его обязанности оказываются связанными. Изменение одной обязанности может привести к тому, что класс перестанет справляться с другими. Такого рода связанность – причина хрупкого дизайна, который неожиданным образом разрушается при изменении.

Если класс отвечает за несколько действий, то его обязанности оказываются связанными. Изменение одной обязанности может привести к тому, что класс перестанет справляться с другими. Такого рода связанность – причина хрупкого дизайна, который неожиданным образом разрушается при изменении.

Рассмотрим пример. У класса ```Rectangle``` есть два метода. Один рисует прямоугольник на экране, другой вычисляет площадь прямоугольника.

![_](./img/solid/solid-img-01.png)
*Более одной обязанности*

Классом ```Rectangle``` пользуются два разных приложения. Одно относится к области вычислительной геометрии. Класс ```Rectangle``` в нем применяется для математических вычислений с геометрическими фигурами, но на экране оно ничего не рисует. Другое приложение графическое, оно может каким-то образом касаться и вычислительной геометрии, но совершенно точно выводит прямоугольник на экран.

Такой дизайн нарушает принцип SRP. У класса ```Rectangle``` две обязанности: предоставление математической модели прямоугольника и рисование прямоугольника в графическом интерфейсе пользователя (UI).

Нарушение SRP порождает ряд серьезных проблем. Во-первых, мы должны включать UI в приложение вычислительной геометрии. В Java придется собирать относящуюся к UI часть системы и развёртывать её вместе с приложением вычислительной геометрии.

Во-вторых, если изменение приложения ```GraphicalApplication``` по какой-то причине потребует изменить класс ```Rectangle```, то нам придется заново собирать, тестировать и развертывать приложение ```ComputationalGeometryApplication```. Если мы забудем об этом, то приложение может неожиданно перестать работать.

Более правильный подход к дизайну состоит в том, чтобы распределить обязанности по двум разным классам. Теперь
вычислительная часть ```Rectangle``` помещена в класс ```GeometricRectangle``` и изменения в алгоритме рисования прямоугольников не могут повлиять на приложение ```ComputationalGeometryApplication```.

![_](./img/solid/solid-img-02.png)
*Обязанности разделены*

### Определение обязанности

В контексте принципа SRP мы будем называть обязанностью причину изменения. Если вы можете найти несколько причин для изменения класса, то у такого класса более одной обязанности. Иногда увидеть это трудно. Мы привыкли воспринимать обязанности группами. Рассмотрим, например, интерфейс ```Modem```. Многие согласятся, что выглядит он совершенно нормально. Все четыре объявленных метода, несомненно, относятся к модему.

*Modem.java - нарушение SRP*

```java
public interface Modem {
    void dial(String pno);
    void hangup();
    void send(char c);
    char receive();
}
```

Однако здесь присутствуют две обязанности: управление соединением (методы ```dial``` и ```hangup```) и передача данных (методы ```send``` и ```receive```).

Следует ли разделить эти обязанности? Все зависит от того, как именно изменяется приложение. Если модификация подразумевает изменение сигнатуры методов управления соединением, то дизайн начинает попахивать "жесткостью", так как классы, вызывающие ```send``` и ```receive```, придётся повторно компилировать и развертывать чаще, чем хотелось бы. В таком случае обязанности следует разделить. Это защищает приложение-клиент от связанности двух обязанностей.

![_](./img/solid/solid-img-03.png)
*Разделённый интерфейс модема*

С другой стороны, если приложение не модифицируют таким образом, что эти обязанности изменяются порознь, то и разделять их нет необходимости. Более того, разделение в этом случае попахивало бы ненужной сложностью.

Отсюда вытекает следствие. *Ось изменения становится таковой, только если изменение имеет место*. Неразумно применять SRP – как и любой другой принцип, если для того нет причин.

### Разделение связанных обязанностей

Обратите внимание, что на предыдущем рисунке обе обязанности связаны в классе ```ModemImplementation```. Это нежелательно, но может оказаться необходимым. Часто имеются причины, обычно относящиеся к деталям оборудования или операционной системы, которые вынуждают нас связывать такие вещи, которые связывать не хотелось бы. Но, разделив интерфейсы, мы развели эти концепции с точки зрения приложения.

Класс ModemImplementation можно считать вынужденным клуджем (англ. [kludge](https://ru.wiktionary.org/wiki/kludge)); однако отметим, что все зависимости ведут от него. Ничто не обязано зависеть от этого класса. Ничто, кроме метода ```main```, не обязано знать о его существовании. Таким образом, мы поместили этого "уродца" за периметр. Его яд не проникнет наружу и не отравит остальное приложение.

### Обеспечение сохранности

На рисунке ниже показано распространенное нарушение принципа SRP. Класс ```Employee``` содержит как бизнес-правила, так и механизмы управления сохранением. Эти обязанности почти никогда не следует смешивать. Бизнес-правила имеют тенденцию часто изменяться, а механизмы сохранения изменяются реже и совершенно по другим причинам. Связывать бизнес-правила с подсистемой сохранения – значит нарываться на неприятности.

![_](./img/solid/solid-img-04.png)
*Связанный механизм сохранения*

К счастью, подход [разработки через тестирование (TDD)](TDD.md) обычно вынуждает разделять эти обязанности задолго до того, как в дизайне появляется "душок". Однако если тесты не заставили это сделать, а аромат "жесткости" и "хрупкости" ощущается всё сильнее, то дизайн следует подвергнуть [рефакторингу](Refactoring.md), применяя для разделения обязанностей паттерны Фасад, DAO (Data Access Object – Объект доступа к данным) или Заместитель (Proxy).

### Выводы

Принцип единственной ответственности – один из самых простых, но при этом его трудно применять правильно. Сочетание обязанностей для нас выглядит совершенно естественно. Их выявление и разделение как раз и является одной из задач проектирования ПО. Мы еще будем неоднократно возвращаться к этой теме при обсуждении остальных принципов.

## Принцип открытости/закрытости

//TBD

## Принцип подстановки Барбары Лисков

//TBD

## Принцип разделения интерфейсов

//TBD

## Принцип инверсии зависимостей

//TBD

## Принцип эквивалентности повторного использования и выпуска

---
**Принцип эквивалентности повторного использования и выпуска (Reuse/Release Equivalence Principle – REP)**

Единица повторного использования равна единице выпуска.

---

Чего вы ожидаете от автора библиотеки классов, которую планируете повторно использовать? Разумеется, хотелось бы иметь хорошую документацию, работающий код, четко специфицированные интерфейсы и т. д. Но это еще не все.

Во-первых, чтобы повторное использование написанного этим автором кода вообще имело смысл, вы хотите иметь гарантию, что автор будет поддерживать свое детище. Ведь если поддерживать код предстоит вам, то придется потратить на его изучение массу времени, а тогда уж лучше спроектировать компонент поменьше, зато под свои конкретные нужды.

Во-вторых, вы хотите, чтобы автор извещал вас обо всех планируемых изменениях в интерфейсе и функциональности кода. Но одного извещения недостаточно. Нужно еще, чтобы автор обеспечил возможность отказаться от использования новых версий. А то, не дай бог, он выпустит новую версию как раз тогда, когда у вас трещит по швам график, или внесет изменения, несовместимые с вашей системой.

Но если вы решите отказаться от новой версии, то автор должен гарантировать поддержку старой версии в течение какого-то периода времени. Может быть, всего три месяца, может быть, год – это вопрос обсуждаемый. Но автор не может просто порвать с вами, отказав во всякой поддержке. Если автор не соглашается поддерживать старые версии, то вы всерьез задумайтесь, стоит ли использовать такой код и целиком зависеть от капризов автора.

Этот вопрос в основном политический. Он касается организационных аспектов процесса поддержки, призванного защитить интересы людей, собирающихся использовать сторонний код. Но политические и организационные вопросы оказывают глубокое влияние на способ пакетирования ПО. Для того чтобы дать гарантии, в которых нуждаются пользователи, автор организует свою программу в виде набора повторно используемых компонентов и присваивает им номера выпуска.

Таким образом, принцип REP гласит, что единица повторного использования, компонент, не может быть меньше единицы выпуска. Все, что предназначено для повторного использования, должно управляться какой-то системой учета выпусков. Не может быть так, чтобы разработчик просто написал какой-то класс и объявил его повторно используемым. О возможности повторного использования можно говорить только тогда, когда внедрена некая система учета выпусков и обеспечены гарантии извещения, надежности и поддержки, в которых так нуждаются потенциальные пользователи.

Принцип REP дает первую подсказку, как разбить дизайн на компоненты. Раз в основе повторного использования должны лежать компоненты, значит, повторно используемые компоненты должны состоять из повторно используемых классов. Поэтому по крайней мере некоторые компоненты должны содержать повторно используемые наборы классов. Тот факт, что разбиение программы определяется политическими факторами, поначалу выглядит настораживающим, но ведь ПО – не математически безупречная сущность, которую можно структурировать, руководствуясь исключительно математически строгими правилами. ПО – продукт деятельности человека, призванный служить человеческим нуждам. ПО создается людьми и для людей. И если мы собираемся его повторно использовать, то и разбивать на компоненты должны так, чтобы людям было удобно.

И какие из этого можно сделать выводы касательно внутренней структуры компонента? Рассматривать его состав следует с точки зрения потенциальных пользователей. Если компонент содержит ПО, которое допускает повторное использование, то в нем не должно быть частей, спроектированных без учета повторного использования. *Либо все классы, включенные в компонент, можно использовать повторно, либо ни один*.

Далее, сам факт повторного использования не является единственным критерием; следует еще принимать во внимание, кто будет использовать компонент. Конечно, библиотеку контейнерных классов можно использовать повторно. Как и каркас для построения финансового ПО. Но вряд ли стоит делать их частями одного и того же компонента, потому что далеко не все заинтересованные в библиотеке контейнерных классов нуждаются в финансовом каркасе. Таким образом, желательно, чтобы все классы в компоненте были ориентированы на одну и ту же аудиторию.

Плохо если потенциальные пользователи обнаружат в компоненте как необходимые, так и совершенно бесполезные для них классы.


## Принцип совместного повторного использования

---
**Принцип совместного повторного использования (Common Reuse Principle – CRP)**

Все классы внутри компонента используются совместно. Если вы можете повторно использовать один класс, то можете использовать и все остальные.

---

Этот принцип помогает решить, какие классы включать в компонент. CRP гласит, что классы, которые, скорее всего, будут использоваться совместно, принадлежат одному компоненту.

Классы редко используются изолированно. Обычно повторно используемые классы кооперируются с другими классами, являющимися частями одной и той же абстракции. CRP утверждает, что такие классы должны входить в один компонент. Естественно ожидать, что между классами в этом компоненте будет много взаимных зависимостей. Простой пример – класс контейнера и сопутствующие ему итераторы. Эти классы используются совместно, потому что они тесно связаны. И, значит, должны принадлежать одному компоненту.

Но CRP говорит не только о том, какие классы помещать в один компонент, а также о том, какие не помещать туда. Если один компонент пользуется другим, то между ними образуется зависимость. Может случиться так, что первому компоненту нужен всего один класс из второго. Но от этого зависимость отнюдь не становится слабее. Первый компонент все равно зависит от второго. При каждом новом выпуске второго компонента придется заново проверять и выпускать первый. И это справедливо даже в том случае, когда причиной нового выпуска используемого компонента является изменение в классе, который использующему компоненту не интересен.

Очень часто компоненты оформляются в виде DLL-библиотек. Если используемый компонент выпущен в виде DLL, то использующий его код зависит от этой DLL в целом. Любая модификация данной DLL, даже если речь идет об изменении класса, который никак не касается использующей программы, обязательно приводит к выпуску новой версии DLL. Новую DLL необходимо повторно развертывать и заново тестировать все использующие ее программы.

Поэтому если уж мой код зависит от некоторого компонента, то я хотел бы, чтобы он зависел от всех классов в этом компоненте. Иными словами, я хочу, чтобы классы, включенные в компонент, были неразделимы, чтобы не получилось так, что клиент зависит от одних и не зависит от других классов. Иначе мне придется заниматься повторным развертыванием и проверкой чаще, чем необходимо, тратя на это несоразмерно много времени.

Итак, принцип CRP даже больше говорит о том, какие классы не следует включать в один компонент, чем о том, какие следует. Смысл CRP в том, что классы, не являющиеся тесно связанными, не должны находиться в одном компоненте.

## Принцип общей закрытости

---
**Принцип общей закрытости (Common Closure Principle – CCP)**

Все классы внутри компонента должны быть закрыты относительно изменений одного и того же вида. Изменение, затрагивающее компонент, должно затрагивать все классы в этом компоненте и только в нем.

---

Это не что иное, как принцип единственной обязанности (SRP) в применении к компонентам. SRP говорит, что у класса не должно быть более одной причины для изменения, а CCP – что то же самое справедливо и для компонента.

В большинстве приложений пригодность для сопровождения важнее повторного использования. Если код приложения приходится изменять, то хотелось бы, чтобы все изменения были локализованы в одном компоненте, а не разбросаны по многим, поскольку это позволит ограничиться повторным развертыванием только одного изменившегося компонента. Другие компоненты, не зависящие от изменившегося, не нужно ни развертывать, ни заново проверять.

Принцип CCP рекомендует собирать в одном месте классы, которые могут изменяться по одним и тем же причинам. Если два класса настолько тесно связаны, физически или концептуально, что всегда изменяются вместе, то их естественно поместить в один компонент. Это уменьшит трудозатраты на повторный выпуск, проверку и распространение ПО.

Этот принцип неотъемлем от принципа открытости/закрытости (OCP). Ибо именно о «закрытости» в смысле OCP и идет речь в CCP. OCP гласит, что классы должны быть закрыты для модификации, но открыты для расширения. Но, как мы узнали, достичь стопроцентной закрытости невозможно. Закрытость должна быть стратегической целью. Мы проектируем систему так, чтобы она была закрыта относительно типичных изменений, с которыми нам приходилось ранее сталкиваться.

CCP развивает эту идею, рекомендуя включать классы, открытые для изменений одного и того же вида, в один компонент. Тогда в случае появления новых требований возрастают шансы на то, что удастся ограничиться изменением минимального числа компонентов.

## Принцип ацикличности зависимостей

---
**Принцип ацикличности зависимостей (Acyclic Dependencies Principle – ADP)**

В графе зависимостей между компонентами не должно быть циклов.

---

//TBD

## Принцип устойчивых зависимостей

---
**Принцип устойчивых зависимостей (Stable-Dependencies Principle – SDP)**

Зависимости должны быть направлены в сторону устойчивости.

---

//TBD

## Принцип устойчивых абстракций

---
**Принцип устойчивых абстракций (Stable-Abstractions Principle – SAP)**

Компонент должен быть столь же абстрактным, сколь и устойчивым.

---

//TBD
